From 5656c0a5bc9cfe4299052a843afeefe23c2cea21 Mon Sep 17 00:00:00 2001
From: Pavel Kubelun <be.dissent@gmail.com>
Date: Wed, 27 Dec 2017 13:06:47 +0300
Subject: [PATCH] ipq806x: enhance L2 cache freq scaling

Allow to set target cpu frequency to take decision on scaling l2 cache
up or down and corresponding voltages to be supplied per frequency.

Signed-off-by: Pavel Kubelun <be.dissent@gmail.com>
---
 drivers/cpufreq/cpufreq-dt.c | 118 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------
 include/linux/cpufreq.h      |   4 ++++
 2 files changed, 100 insertions(+), 22 deletions(-)

diff --git a/drivers/cpufreq/cpufreq-dt.c b/drivers/cpufreq/cpufreq-dt.c
index ac5d348..4bdb080 100644
--- a/drivers/cpufreq/cpufreq-dt.c
+++ b/drivers/cpufreq/cpufreq-dt.c
@@ -37,6 +37,9 @@ struct private_data {
 	unsigned long opp_freq;
 };
 
+static unsigned int voltage_tolerance; /* in percentage */
+static struct regulator *l2_regulator;
+
 static struct freq_attr *cpufreq_dt_attr[] = {
 	&cpufreq_freq_attr_scaling_available_freqs,
 	NULL,   /* Extra space for boost-attr if required */
@@ -50,33 +53,48 @@ static int set_target(struct cpufreq_policy *policy, unsigned int index)
 	unsigned long target_freq = policy->freq_table[index].frequency * 1000;
 	struct clk *l2_clk = policy->l2_clk;
 	unsigned int l2_freq;
-	unsigned long new_l2_freq = 0;
+	unsigned long new_l2_freq = 0, new_l2_volt = 0;
 
 	mutex_lock(&priv->lock);
 	ret = dev_pm_opp_set_rate(priv->cpu_dev, target_freq);
 
 	if (!ret) {
-		if (!IS_ERR(l2_clk) && policy->l2_rate[0] && policy->l2_rate[1] &&
-				policy->l2_rate[2]) {
-			static unsigned long krait_l2[CONFIG_NR_CPUS] = { };
-			int cpu, ret = 0;
-
-			if (target_freq >= policy->l2_rate[2])
-				new_l2_freq = policy->l2_rate[2];
-			else if (target_freq >= policy->l2_rate[1])
-				new_l2_freq = policy->l2_rate[1];
-			else
-				new_l2_freq = policy->l2_rate[0];
+		if (!IS_ERR(l2_clk) && policy->l2_rate_defined) {
+			static unsigned long l2_freq_scaling[CONFIG_NR_CPUS] = { };
+			int cpu, i, tol = 0, ret = 0;
+
+			for (i = 2; i >= 0; i--) {
+				if (target_freq >= policy->l2_cpufreq[i]) {
+					new_l2_freq = policy->l2_rate[i];
+					if (!IS_ERR(l2_regulator)) {
+						new_l2_volt = policy->l2_volt[i];
+						tol = policy->l2_volt[i] * voltage_tolerance / 100;
+					}
+					break;
+				}
+			}
 
-			krait_l2[policy->cpu] = new_l2_freq;
+			l2_freq_scaling[policy->cpu] = new_l2_freq;
 			for_each_present_cpu(cpu)
-				new_l2_freq = max(new_l2_freq, krait_l2[cpu]);
+				new_l2_freq = max(new_l2_freq, l2_freq_scaling[cpu]);
 
 			l2_freq = clk_get_rate(l2_clk);
 
-			if (l2_freq != new_l2_freq) {
-				/* scale l2 with the core */
+			if (l2_freq > new_l2_freq) {
+				/* scale l2 with the core, lower the frequency first */
 				ret = clk_set_rate(l2_clk, new_l2_freq);
+				if (!ret && !IS_ERR(l2_regulator))
+					ret = regulator_set_voltage_tol(l2_regulator, new_l2_volt, tol);
+			}
+			if (l2_freq < new_l2_freq) {
+				/* scale l2 with the core, rise the voltage first */
+				if (!IS_ERR(l2_regulator)) {
+					ret = regulator_set_voltage_tol(l2_regulator, new_l2_volt, tol); 
+					if (!ret)
+						ret = clk_set_rate(l2_clk, new_l2_freq);
+				}
+				else
+					ret = clk_set_rate(l2_clk, new_l2_freq);
 			}
 		}
 
@@ -231,6 +249,7 @@ static int cpufreq_init(struct cpufreq_policy *policy)
 	struct srcu_notifier_head *opp_srcu_head;
 	struct device_node *l2_np;
 	struct clk *l2_clk = NULL;
+	struct device_node *np, *cache;
 
 	cpu_dev = get_cpu_device(policy->cpu);
 	if (!cpu_dev) {
@@ -355,12 +374,63 @@ static int cpufreq_init(struct cpufreq_policy *policy)
 		policy->suspend_freq = dev_pm_opp_get_freq(suspend_opp) / 1000;
 	rcu_read_unlock();
 
-	l2_clk = clk_get(cpu_dev, "l2");
-	if (!IS_ERR(l2_clk))
-		policy->l2_clk = l2_clk;
-	l2_np = of_find_node_by_name(NULL, "qcom,l2");
-	if (l2_np)
-		of_property_read_u32_array(l2_np, "qcom,l2-rates", policy->l2_rate, 3);
+	np = of_node_get(priv->cpu_dev->of_node);
+	if (np)
+		cache = of_find_next_cache_node(np);
+
+	if (cache) {
+		struct device_node *vdd;
+		policy->l2_rate_defined = false;
+		policy->l2_volt_defined = false;
+
+		l2_clk = clk_get(cache, NULL);
+		if (!IS_ERR(l2_clk))
+			policy->l2_clk = l2_clk;
+			of_property_read_u32_array(cache, "l2-rates", policy->l2_rate, 3);
+		else
+			pr_warn("L2 cache: clock not found \n");
+
+		if (policy->l2_rate[0] && policy->l2_rate[1] && policy->l2_rate[2]) 
+			policy->l2_rate_defined = true;
+			else
+				pr_warn("L2 cache: failed to parse rates from the Device Tree,
+						scaling disabled \n");
+
+		if (policy->l2_rate_defined) {
+			of_property_read_u32_array(cache, "l2-cpufreq", policy->l2_cpufreq, 3);
+			if (!policy->l2_cpufreq[0] || !policy->l2_cpufreq[1] ||
+				!policy->l2_cpufreq[2]) {
+				pr_warn("L2 cache: failed to parse target cpu frequency from the Device
+							Tree, using defaults instead \n");
+				policy->l2_cpufreq = policy->l2_rate;
+			}
+
+			of_property_read_u32_array(cache, "l2-volt", policy->l2_volt, 3);
+			if (policy->l2_volt[0] && policy->l2_volt[1] && policy->l2_volt[2])
+				policy->l2_volt_defined = true;
+				else
+					pr_warn("L2 cache: failed to parse voltage from the Device Tree \n");
+
+			if (policy->l2_volt_defined) {
+				
+				ret = of_property_read_u32(np, "voltage-tolerance", &voltage_tolerance);
+				if (!ret)
+					vdd = of_parse_phandle(cache, "l2-supply", 0);
+				else
+					pr_warn("L2 cache: failed to parse voltage tolerance\n");
+
+				if (!vdd)
+					pr_warn("L2 cache: failed to parse supply regulator phandle\n");
+			}
+
+			if (vdd) {
+				l2_regulator = regulator_get(NULL, vdd->name);
+				if (IS_ERR(l2_regulator))
+					pr_warn("L2 cache: failed to get supply regulator\n");
+				of_node_put(vdd);
+			}
+		}
+	}
 
 	ret = cpufreq_table_validate_and_show(policy, freq_table);
 	if (ret) {
@@ -393,10 +463,12 @@ out_unregister_nb:
 out_free_priv:
 	kfree(priv);
 out_free_opp:
+	regulator_put(l2_regulator);
 	dev_pm_opp_of_cpumask_remove_table(policy->cpus);
 	if (name)
 		dev_pm_opp_put_regulator(opp_table);
 out_put_clk:
+	clk_put(l2_clk);
 	clk_put(cpu_clk);
 
 	return ret;
@@ -408,10 +480,12 @@ static int cpufreq_exit(struct cpufreq_policy *policy)
 
 	cpufreq_cooling_unregister(priv->cdev);
 	dev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);
+	regulator_put(l2_regulator);
 	dev_pm_opp_of_cpumask_remove_table(policy->related_cpus);
 	if (priv->reg_name)
 		dev_pm_opp_put_regulator(priv->opp_table);
 
+	clk_put(policy->l2_clk);
 	clk_put(policy->clk);
 	kfree(priv);
 
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9c0a4b5..9650ad3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -75,6 +75,10 @@ struct cpufreq_policy {
 	struct clk		*clk;
 	struct clk		*l2_clk; /* L2 clock */
 	unsigned int		l2_rate[3]; /* L2 bus clock rate thresholds */
+	bool				l2_rate_defined
+	unsigned int		l2_cpufreq[3]; /* L2 target CPU frequency */
+	unsigned int		l2_volt[3]; /* L2 voltage array */
+	bool				l2_volt_defined
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 
 	unsigned int		min;    /* in kHz */
--
Working Copy 3.0.6

